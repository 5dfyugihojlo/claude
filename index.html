<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>GG AI — Powered by Puter.js</title>
    <script src="https://js.puter.com/v2/"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.2/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/dark.min.css">
    <style>
        body{margin:0;font-family:system-ui;background:#111;color:#eee;display:flex;height:100vh}
        #sidebar{min-width:240px;background:#1e1e1e;border-right:1px solid #333;padding:10px;display:flex;flex-direction:column}
        #sidebar button{width:100%;margin:4px 0;padding:8px;border:none;border-radius:4px;background:#222;color:#eee;cursor:pointer}
        #sidebar button:hover{background:#333}
        #sidebar button.active{background:#0a4c6b}
        #chat{flex:1;display:flex;flex-direction:column}
        #messages{flex:1;padding:10px;overflow-y:auto}
        .msg{margin:6px 0;padding:8px;border-radius:6px;max-width:75%;word-break:break-word;line-height:1.6}
        .user{background:#0a4c6b;margin-left:auto}
        .bot{background:#333}
        
        /* Enhanced formatting for bot messages */
        .bot p{margin:0.8em 0;line-height:1.6}
        .bot ul, .bot ol{margin:0.8em 0;padding-left:1.5em}
        .bot li{margin:0.3em 0}
        .bot h1, .bot h2, .bot h3, .bot h4, .bot h5, .bot h6{margin:1em 0 0.5em 0;color:#fff}
        .bot blockquote{border-left:3px solid #0a4c6b;padding-left:1em;margin:1em 0;font-style:italic}
        .bot strong{color:#fff}
        .bot em{color:#ccc}
        
        /* Code block styling */
        .code-container{
            position:relative;
            margin:1em 0;
            background:#1a1a1a;
            border:1px solid #333;
            border-radius:8px;
            overflow:hidden;
        }
        .code-header{
            background:#2a2a2a;
            padding:8px 12px;
            border-bottom:1px solid #333;
            display:flex;
            justify-content:space-between;
            align-items:center;
            font-size:12px;
            color:#888;
        }
        .code-language{
            font-weight:bold;
            color:#0a84ff;
        }
        .code-actions{
            display:flex;
            gap:8px;
        }
        .code-btn{
            background:#0a4c6b;
            color:#fff;
            border:none;
            padding:4px 8px;
            border-radius:4px;
            cursor:pointer;
            font-size:11px;
            transition:background 0.2s;
        }
        .code-btn:hover{
            background:#0d5a7a;
        }
        .code-btn:active{
            background:#094158;
        }
        .code-content{
            overflow-x:auto;
        }
        .code-content pre{
            margin:0;
            padding:12px;
            background:transparent;
        }
        .code-content code{
            background:transparent;
            color:#e6e6e6;
            font-family:'Courier New', monospace;
            font-size:13px;
            line-height:1.4;
        }
        
        /* Inline code */
        .bot :not(pre) > code{
            background:#2a2a2a;
            color:#e6e6e6;
            padding:2px 6px;
            border-radius:3px;
            font-family:'Courier New', monospace;
            font-size:0.9em;
        }
        
        #controls{display:flex;align-items:center;padding:10px;border-top:1px solid #333}
        #controls input[type=text]{flex:1;padding:8px;border-radius:4px;border:none;margin-right:6px}
        #controls input[type=file]{display:none}
        #controls label{background:#0a4c6b;color:#fff;padding:8px 12px;border-radius:4px;margin-right:6px;cursor:pointer}
        #controls select{background:#222;color:#eee;border:none;padding:6px;border-radius:4px}
        #controls button{background:#0a4c6b;color:#fff;border:none;padding:8px 12px;border-radius:4px;cursor:pointer}
        #controls button:disabled{opacity:.5;cursor:not-allowed}
        .status{font-size:12px;color:#888;text-align:center;padding:5px}
        
        /* Copy notification */
        .copy-notification{
            position:fixed;
            top:20px;
            right:20px;
            background:#0a4c6b;
            color:#fff;
            padding:8px 16px;
            border-radius:6px;
            z-index:1000;
            opacity:0;
            transition:opacity 0.3s;
        }
        .copy-notification.show{
            opacity:1;
        }
    </style>
</head>
<body>

<!-- Sidebar -->
<div id="sidebar">
    <button onclick="newChat()">➕ New Chat</button>
    <div class="status" id="chatStatus">Fresh Session</div>
    <div id="history"></div>
</div>

<!-- Chat -->
<div id="chat">
    <div id="messages"></div>
    <div id="controls">
        <input id="msgInput" type="text" placeholder="Type a message…" onkeydown="if(event.key==='Enter')sendMsg()"/>
        <label for="fileInput">🔎</label>
        <input id="fileInput" type="file" multiple onchange="handleFiles()"/>
        <select id="modelSelect">
            <option value="gpt-5">GPT 5</option>
            <option value="claude-opus-4">Claude Opus 4</option>
            <option value="claude-sonnet-4">Claude Sonnet 4</option>
        </select>
        <button onclick="sendMsg()" id="sendBtn">Send</button>
    </div>
</div>

<!-- Copy notification -->
<div id="copyNotification" class="copy-notification">Copied to clipboard!</div>

<script>
/* ---------- GLOBAL STATE ---------- */
let activeThreadId = localStorage.getItem('activeThreadId') || generateId();
let threads = JSON.parse(localStorage.getItem('threads') || '{}');
let conversationContext = []; // This will be reset for each new chat
let sessionId = generateId(); // Unique session ID for API context

if (!threads[activeThreadId]) {
    threads[activeThreadId] = {title:'New Chat', msgs:[], sessionId: sessionId};
}

// Initialize conversation context from active thread
initializeContext();
renderMessages();
renderHistory();
updateStatus();

/* ---------- HELPERS ---------- */
function generateId(){ return Date.now().toString(36)+Math.random().toString(36).slice(2); }

function saveThreads(){ 
    localStorage.setItem('threads', JSON.stringify(threads)); 
    localStorage.setItem('activeThreadId', activeThreadId);
}

function scrollDown(){ 
    const m=document.getElementById('messages'); 
    m.scrollTop=m.scrollHeight; 
}

function updateStatus(){
    const status = document.getElementById('chatStatus');
    const msgCount = conversationContext.length;
    if(msgCount === 0) {
        status.textContent = 'Fresh Session';
        status.style.color = '#4a9';
    } else {
        status.textContent = `${msgCount} messages in context`;
        status.style.color = '#888';
    }
}

function initializeContext(){
    // Reset conversation context when switching threads
    conversationContext = [];
    sessionId = threads[activeThreadId].sessionId || generateId();
    if(!threads[activeThreadId].sessionId) {
        threads[activeThreadId].sessionId = sessionId;
        saveThreads();
    }
}

/* ---------- MARKDOWN & CODE PROCESSING ---------- */
function processMarkdown(text) {
    // Configure marked for better code block handling
    marked.setOptions({
        highlight: function(code, lang) {
            if (lang && hljs.getLanguage(lang)) {
                try {
                    return hljs.highlight(code, { language: lang }).value;
                } catch (__) {}
            }
            return hljs.highlightAuto(code).value;
        },
        breaks: true,
        gfm: true
    });
    
    return marked.parse(text);
}

function enhanceCodeBlocks(html) {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    
    const codeBlocks = tempDiv.querySelectorAll('pre code');
    codeBlocks.forEach((codeElement, index) => {
        const preElement = codeElement.parentElement;
        const code = codeElement.textContent;
        const language = codeElement.className.match(/language-(\w+)/)?.[1] || 'text';
        
        // Create enhanced code container
        const container = document.createElement('div');
        container.className = 'code-container';
        
        const header = document.createElement('div');
        header.className = 'code-header';
        
        const langSpan = document.createElement('span');
        langSpan.className = 'code-language';
        langSpan.textContent = language.toUpperCase();
        
        const actions = document.createElement('div');
        actions.className = 'code-actions';
        
        const copyBtn = document.createElement('button');
        copyBtn.className = 'code-btn';
        copyBtn.textContent = 'Copy';
        copyBtn.onclick = () => copyCode(code);
        
        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'code-btn';
        downloadBtn.textContent = 'Download';
        downloadBtn.onclick = () => downloadCode(code, language, index);
        
        actions.appendChild(copyBtn);
        actions.appendChild(downloadBtn);
        
        header.appendChild(langSpan);
        header.appendChild(actions);
        
        const content = document.createElement('div');
        content.className = 'code-content';
        content.appendChild(preElement.cloneNode(true));
        
        container.appendChild(header);
        container.appendChild(content);
        
        preElement.parentElement.replaceChild(container, preElement);
    });
    
    return tempDiv.innerHTML;
}

function copyCode(code) {
    navigator.clipboard.writeText(code).then(() => {
        showCopyNotification();
    }).catch(err => {
        console.error('Failed to copy code:', err);
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = code;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showCopyNotification();
    });
}

function downloadCode(code, language, index) {
    const extensions = {
        'javascript': 'js',
        'typescript': 'ts',
        'python': 'py',
        'java': 'java',
        'cpp': 'cpp',
        'c': 'c',
        'csharp': 'cs',
        'html': 'html',
        'css': 'css',
        'php': 'php',
        'ruby': 'rb',
        'go': 'go',
        'rust': 'rs',
        'swift': 'swift',
        'kotlin': 'kt',
        'sql': 'sql',
        'json': 'json',
        'xml': 'xml',
        'yaml': 'yml',
        'shell': 'sh',
        'bash': 'sh'
    };
    
    const extension = extensions[language.toLowerCase()] || 'txt';
    const filename = `code_${index + 1}.${extension}`;
    
    const blob = new Blob([code], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function showCopyNotification() {
    const notification = document.getElementById('copyNotification');
    notification.classList.add('show');
    setTimeout(() => {
        notification.classList.remove('show');
    }, 2000);
}

/* ---------- CHAT HISTORY ---------- */
function renderHistory(){
    const h=document.getElementById('history'); 
    h.innerHTML='';
    
    // Sort threads by last activity (most recent first)
    const sortedThreads = Object.entries(threads).sort((a, b) => {
        const aTime = a[1].lastActivity || 0;
        const bTime = b[1].lastActivity || 0;
        return bTime - aTime;
    });
    
    sortedThreads.forEach(([id, th])=>{
        const b=document.createElement('button');
        b.textContent = th.title || 'New Chat';
        b.onclick = ()=>switchThread(id);
        if(id === activeThreadId) b.classList.add('active');
        h.appendChild(b);
    });
}

function switchThread(id){
    activeThreadId = id;
    initializeContext(); // Reset context for the switched thread
    renderMessages();
    renderHistory();
    updateStatus();
}

function newChat(){
    const id = generateId();
    sessionId = generateId(); // New session ID for fresh context
    threads[id] = {
        title: 'New Chat', 
        msgs: [],
        sessionId: sessionId,
        lastActivity: Date.now()
    };
    activeThreadId = id;
    conversationContext = []; // Fresh context
    saveThreads();
    renderMessages();
    renderHistory();
    updateStatus();
    
    // Clear any uploaded files
    uploadedFiles = [];
    document.getElementById('fileInput').value = '';
}

/* ---------- MESSAGES ---------- */
function renderMessages(){
    const m=document.getElementById('messages'); 
    m.innerHTML='';
    threads[activeThreadId].msgs.forEach(({role,text,image})=>{
        const div=document.createElement('div');
        div.className='msg '+(role==='user'?'user':'bot');
        if(image){
            const img=document.createElement('img');
            img.src=image; 
            img.style.maxWidth='200px'; 
            img.style.borderRadius='6px';
            div.appendChild(img);
            div.appendChild(document.createElement('br'));
        }
        
        if(role === 'bot') {
            // Process markdown and enhance code blocks for bot messages
            const markdownHtml = processMarkdown(text);
            const enhancedHtml = enhanceCodeBlocks(markdownHtml);
            div.innerHTML = div.innerHTML + enhancedHtml;
        } else {
            // Keep user messages as plain text
            div.appendChild(document.createTextNode(text));
        }
        
        m.appendChild(div);
    });
    scrollDown();
}

function addMsg(role, text, image){
    const msg = {role, text, image, timestamp: Date.now()};
    threads[activeThreadId].msgs.push(msg);
    threads[activeThreadId].lastActivity = Date.now();
    
    // Add to conversation context (this is what gets sent to API)
    conversationContext.push({role, content: text});
    
    // Keep context manageable - limit to last 20 messages
    if(conversationContext.length > 20) {
        conversationContext = conversationContext.slice(-20);
    }
    
    saveThreads();
    renderMessages();
    updateStatus();
}

/* ---------- FILE UPLOAD ---------- */
let uploadedFiles=[];   // {type,url,name}

async function handleFiles(){
    const files=[...document.getElementById('fileInput').files];
    for(const f of files){
        try {
            const path = await puter.fs.upload(f, '/tmp/'+f.name);
            uploadedFiles.push({type:f.type, url:path.url, name:f.name});
            addMsg('user',`🔎 Uploaded ${f.name}`);
        } catch(err) {
            console.error('File upload error:', err);
            addMsg('bot', `⚠️ Failed to upload ${f.name}: ${err.message}`);
        }
    }
}

/* ---------- SEND ---------- */
async function sendMsg(){
    const input=document.getElementById('msgInput');
    const text=input.value.trim();
    if(!text && uploadedFiles.length===0) return;

    const userMessage = text || 'Uploaded file(s)';
    addMsg('user', userMessage);
    input.value='';

    // Disable UI
    document.getElementById('sendBtn').disabled=true;
    
    const model=document.getElementById('modelSelect').value;

    try{
        let prompt = text;
        let requestOptions = {
            model: model,
            stream: true,
            session: sessionId // Use session ID for context
        };

        if(uploadedFiles.length){
            if(uploadedFiles.some(f=>f.type.startsWith('image/'))){
                // Vision prompt
                const imgUrl=uploadedFiles.find(f=>f.type.startsWith('image/')).url;
                requestOptions.image = imgUrl;
            } else {
                prompt += " [Attached file(s): " + uploadedFiles.map(f=>f.name).join(', ') + "]";
            }
        }

        // Send only the current message, let the session handle context
        const stream = await puter.ai.chat(prompt, requestOptions);
        await streamReply(stream);
        
    }catch(err){
        console.error('Send error:', err);
        addMsg('bot','⚠️ Error: ' + err.message);
        
        // If it's a context/session error, suggest starting a new chat
        if(err.message.includes('context') || err.message.includes('session') || err.message.includes('limit')) {
            addMsg('bot', '💡 Try starting a new chat to reset the session if this error persists.');
        }
    }finally{
        uploadedFiles=[];
        document.getElementById('fileInput').value = '';
        document.getElementById('sendBtn').disabled=false;
    }
}

/* ---------- STREAM ---------- */
async function streamReply(stream){
    let buffer='';
    const div=document.createElement('div'); 
    div.className='msg bot';
    document.getElementById('messages').appendChild(div);
    scrollDown();

    try {
        for await (const chunk of stream){
            const txt=chunk?.text || '';
            buffer+=txt;
            
            // For streaming, show plain text first, then enhance on completion
            div.innerHTML = buffer.replace(/\n/g, '<br>');
            scrollDown();
        }
        
        // Once streaming is complete, process markdown and enhance code blocks
        const markdownHtml = processMarkdown(buffer);
        const enhancedHtml = enhanceCodeBlocks(markdownHtml);
        div.innerHTML = enhancedHtml;
        
        // Add bot response to thread but not to context (avoid duplication)
        const msg = {role: 'bot', text: buffer, timestamp: Date.now()};
        threads[activeThreadId].msgs[threads[activeThreadId].msgs.length - 1] = msg;
        threads[activeThreadId].lastActivity = Date.now();
        
        // Add to conversation context
        conversationContext.push({role: 'bot', content: buffer});
        
        // Keep context manageable
        if(conversationContext.length > 20) {
            conversationContext = conversationContext.slice(-20);
        }
        
        saveThreads();
        updateStatus();
        
        // Auto-rename thread based on first user message
        if(threads[activeThreadId].title === 'New Chat' && threads[activeThreadId].msgs.length >= 2){
            const firstUser = threads[activeThreadId].msgs.find(m=>m.role==='user');
            if(firstUser) {
                threads[activeThreadId].title = firstUser.text.slice(0, 30) + (firstUser.text.length > 30 ? '...' : '');
                saveThreads();
                renderHistory();
            }
        }
    } catch(err) {
        console.error('Stream error:', err);
        div.innerHTML = buffer.replace(/\n/g, '<br>') + '<br><br>⚠️ Stream interrupted: ' + err.message;
        
        // Add the interrupted message to thread
        const msg = {role: 'bot', text: buffer + '\n\n⚠️ Stream interrupted: ' + err.message, timestamp: Date.now()};
        threads[activeThreadId].msgs[threads[activeThreadId].msgs.length - 1] = msg;
        saveThreads();
    }
}

/* ---------- CLEANUP ---------- */
// Clean up old temporary files periodically
setInterval(() => {
    if(uploadedFiles.length === 0 && Math.random() < 0.1) {
        // Occasionally clean up old threads (keep only last 50)
        const threadEntries = Object.entries(threads);
        if(threadEntries.length > 50) {
            const sorted = threadEntries.sort((a, b) => (b[1].lastActivity || 0) - (a[1].lastActivity || 0));
            const toKeep = sorted.slice(0, 50);
            threads = Object.fromEntries(toKeep);
            saveThreads();
        }
    }
}, 60000); // Check every minute

// Initialize syntax highlighting
document.addEventListener('DOMContentLoaded', function() {
    hljs.highlightAll();
});
</script>
</body>
</html>
